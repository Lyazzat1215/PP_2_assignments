
1:
git config --global user.name "Lyazzat1215"       # Устанавливаем имя для коммитов
git config --global user.email " lyazzat.onerkhan06@mail.ru"   # Устанавливаем email для коммитов

git config --global init.defaultBranch main     # Делаем main веткой по умолчанию

git config --global core.autocrlf input         # Корректная обработка окончаний строк (Unix/Mac)
git config --global core.safecrlf warn          # Предупреждать о некорректных окончаниях строк

2:
mkdir work             # создаём папку проекта под названием work  
cd work                # переходим в эту папку

touch hello.html       # создаём файл hello.html  
# (можно открыть его и записать в него “Hello, World” или что угодно)

git init               # создаём пустой Git-репозиторий  
# после этой команды внутри папки появится скрытая папка .git — это сам репозиторий

git add hello.html     # добавляем файл hello.html в staging area  
# теперь Git знает, что этот файл мы хотим включить в следующий коммит

git commit -m "Initial commit"  
# создаём коммит с записанным состоянием файла hello.html  
# сообщение коммита “Initial commit” — краткое пояснение, что это первый коммит

[main (root-commit) 5836970] -Git сообщает о созданий коммита в ветке main, и что это корневой коммит (root-commit).

1 file changed #изменения в одном файле, 1 insertion(+)  #количество добавленных строк

create mode 100644 hello.html- файл был создан с правами доступа

3: 
git status        # Проверяем текущее состояние репозитория  

On branch main-нахождение в ветке с именем main 
nothing to commit #нет зафиксированных изменений, working tree clean # нет сохраненных изменений

git branch -m master main   # переименовываем локальную ветку из master в main  

4-5:

# Открыть файл hello.html и редактировать содержимое, например:
#  добавлять <h1>Hello, World!</h1>
git status    # Проверяем статус после изменения файла  
Результат:
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   hello.html #гит видит что есть изменения но они еще не утверждены, то есть нужно закоммитить

no changes added to commit (use "git add" and/or "git commit -a")

Дальше:

git add hello.html     # говорим гиту : “я хочу включить изменённый hello.html в следующий коммит”

git commit -m "Update hello.html, добавлен h1 тег"   # фикс изменения с комментарием

git restore hello.html    # сбросить изменения в этом файле(передумали, надо обратно)

6:
git add a.html         # добавляем изменения из a.html в индекс (staging area)
git add b.html         # добавляем изменения из b.html в индекс
git commit -m "Fix layout in a and b"  
# коммитим изменения, которые уже добавлены в индекс — то есть a.html и b.html

git add c.html         # теперь отдельно добавляем изменения из c.html в индекс
git commit -m "Update content in c"  
# делаем второй коммит только с изменениями из c.html

7: 
git add hello.html        # добавляем изменённый файл в staging area

git commit -m "Изменён hello.html: добавлен заголовок"  
# создаём коммит с сообщением "Изменён hello.html: добавлен заголовок"
# -m означает "message" — короткое пояснение того, что изменилось

Результат:
[main abc1234] Изменён hello.html: добавлен заголовок
 1 file changed, 1 insertion(+)

8:

git status
Результат:
On branch main
Changes not staged for commit:
  modified:   hello.html

git add hello.html     # добавляем текущие изменения в индекс
Результат:
[main def4567] Добавлен новый абзац в hello.html
 1 file changed, 3 insertions(+)

9: 
Команды:

git log                      # показывает полный лог коммитов
git log --oneline            # более компактный вид: одна строка на коммит
git log -p                    # показывает не просто заголовки, а “патчи” — что добавлено/удалено
git log --stat               # показывает статистику изменений по файлам (сколько строк добавлено/удалено)
git show <hash>               # показать подробности конкретного коммита по его хешу
git diff <коммит1> <коммит2>  # показать разницу между двумя коммитами

	•	--pretty="..." — определяет формат вывода.
	•	%h — укороченный хеш коммита.
	•	%ad — дата коммита.
	•	| — просто визуальный разделитель.
	•	%s — комментарий.
	•	%d — дополнения коммита («головы» веток или теги).
	•	%an — имя автора.
	•	--date=short — сохраняет формат даты коротким и симпатичным.

10:

1.	Сначала ты смотрим историю коммитов с помощью git log, находим хеш нужного коммита.  
	2.	Потом git checkout <hash> чтобы переключить рабочую директорию на состояние этого коммита.  
	•	в состоянии detached HEAD — то есть мы ни в одной ветке, просто смотришь “старую версию”.  
	3.	Чтобы вернуться к последней версии ветки (например, main), —> git switch

11: 
git tag v1            # создаём лёгкий (lightweight) тег с именем v1

git checkout v1^              # переключаемся на коммит до v1 (detached HEAD)
git tag v1-beta                # создаём тег v1-beta на этом коммите

12:
Если я изменила файл на диске (в рабочей директории), но ещё не добавляла его в staging (то есть не выполнила git add), и нужно просто отменить эти изменения, тоесть вернуть файл к состоянию последнего коммита.  
Для этого используется команда git restore <file> (новый способ) или эквивалентные старые команды (git checkout -- <file>) в более старых версиях Git.  

13: 
	1.	редачим файл 
	2.	Добавляем : git add hello.html        # подготовить изменения (staging)
	3.	Проверим: git status
	4.	Чтобы убрать файл из staging:
         git restore --staged hello.html   # файл больше не будет готов к коммиту, но изменения всё ещё в рабочей копии
	5.	полностью возвращаем: git restore hello.html   # сбросить изменения в рабочей копии, вернуть к состоянию последнего коммита
	6.	Проверяем
